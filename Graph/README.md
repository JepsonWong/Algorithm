## 参考

[极大连通子图 + 极小连通子图 + 连通分量](https://blog.csdn.net/qq_38262266/article/details/77010230)

[有向图强连通分量的Tarjan算法](https://www.byvoid.com/zhs/blog/scc-tarjan)

## 求连通子图／连通分量

**有向图**：强连通、强连通图、极大强连通子图（强连通分量）。

**无向图**：连通、连通子图。

并查集：求无向图的所有连通子图。

Tarjan：求有向图强连通分量。

极大连通子图、极小连通子图；有向图不存在极小连通子图。

https://blog.csdn.net/qq\_38262266/article/details/77010230

## 求生成树和最小生成树

贪心策略。有prime算法和kruskal算法。

### prime算法(每次选点)

* 清空生成树，任取一个顶点加入生成树。
* 在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树。
* 重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树。

### kruskal算法(**可以利用并查集**)(每次选边)

构造一个只含n个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树的根节点，则它是一个含有n棵树的森林。之后，从网的边集中**选取一条权值最小的边**，**若该边的两个顶点分属不同的树**，则将其加入子图，也就是这两个顶点分别所在的两棵树合成一棵树；反之，**若该边的两个顶点已落在同一棵树上**，则不可取，而应该取下一条权值最小的边再试之。依次类推，**直至森林只有一棵树**。kruskal算法能够在并查集的基础很快的实现。 

### Kruskal VS Prim

方法上：Kruskal在所有边中不断寻找最小的边，Prim在U和V两个集合之间寻找权值最小的连接，共同点是构造过程都不能形成环。

时间上：Prim适合稠密图，复杂度为O(n * n)，因此通常使用邻接矩阵储存，复杂度为O(e * loge)；而Kruskal多用邻接表。稠密图Prim > Kruskal，稀疏图Kruskal > Prim。

空间上：Prim适合点少边多，Kruskal适合边少点多。

## 求最短路径

最短路径问题旨在寻找图中两节点之间的最短路径。

**无向图的最短路径又叫做最小生成树**，有prime算法和kruskal算法。

有向图的最短路径算法有dijkstra算法和floyd算法。

### floyd

最简单的最短路径算法，可以计算图中任意两点间的最短路径。folyd算法的时间复杂度是O(N3)。

### dijkstra

用来计算从一个点到其他所有点的最短路径的算法，复杂度O(N2)。
