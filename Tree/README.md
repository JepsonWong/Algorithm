## Tree的好多问题：没看完

https://www.cnblogs.com/love-yh/p/7248136.html

## Tree的先序、中序、后序遍历，递归、非递归遍历

https://blog.csdn.net/shanghairuoxiao/article/details/73752446 前序，感觉里面的中序遍历非递归有点问题，后序遍历

https://www.cnblogs.com/SHERO-Vae/p/5800363.html 中序

## 层次遍历，记住每层有多少节点

## 使用前序遍历、中序遍历、后续遍历中的两种构建二叉树

前序遍历+中序遍历，中序遍历+后序遍历都可以实现二叉树的构造。前序遍历和后序遍历不能实现二叉树的构造，因为没法根据根节点的位置将左右子树分开。这两种构造方式一样，都是根据节点确定左右子树，然后依次找到以每个节点的左右子树，递归实现构造二叉树。

https://www.cnblogs.com/love-yh/p/7248136.html

## Range Tree

用于**范围搜索**。

https://blog.csdn.net/liuqiyao\_01/article/details/8478719

## KD-Tree

用于**高维空间中的快速最近邻和近似最近邻查找技术**。

https://blog.csdn.net/u012423865/article/details/77488920

https://blog.csdn.net/yangguangjingren/article/details/50696483

https://blog.csdn.net/dylan\_frank/article/details/77934272

### 两个用途

查询离某个点**最近的k个邻居**。搜索**某个区域的所有点**。

### 建树

从某一维度对点集进行分割；依次递归。

根据哪个维度对子空间进行划分。一般是选择轮流来，但是为了尽快缩小检索范围，用方差最大的维度。（方差最大的维度更为分散）

选定根节点的比对数值。一般选取中值。

**KD-Tree和BST的区别**：

BST的每个节点存储的是值，而KD-Tree的根节点和中间节点存储的是对某个维度的划分信息，只有叶节点里才是存储的值。

### KNN查找

根据点p，查找离其最近的k个点，树的当前节点o(初始节点为根节点)。

方法1: 访问叶子节点+回溯

方法2: Best Bin First算法。自定义最大回溯次数，将树分支所在的树中位置和p的距离保存在优先级队列Queue中。

## Trie

又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是**用于统计，排序和保存大量的字符串**（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的**公共前缀**来减少查询时间，最大限度地减少无谓的字符串比较，**查询效率比哈希树高**。

Trie的强大之处就在于它的时间复杂度。它的**插入和查询时间复杂度都为O(k)**，其中k为key的长度，与Trie中保存了多少个元素无关。Hash表号称是O(1)的，但在计算hash的时候就肯定会是O(k) ，而且还有碰撞之类的问题；Trie的**缺点是空间消耗很高**。

至于**Trie树的实现，可以用数组，也可以用指针动态分配**，做题时为了方便可以用数组，静态分配空间。

源代码：

https://blog.csdn.net/nk\_test/article/details/47836119

https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html

https://blog.csdn.net/gao1440156051/article/details/51357135

指针模板/数组模板：https://blog.csdn.net/jinzhao1993/article/details/52966761

### 数据结构

指针模板：

```
#define MAX_CHILD 26
struct Node {
	int val; //前缀出现次数
	Node* next[MAX_CHILD];
	Node() {
		val = 0;
		memset(next, 0, sizeof(next));
	}
}
Node* root = new Node(); //创建一个新的Trie树
```

数组模板：父节点对儿子节点的指向是这样实现的，对每个节点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是儿子对应在大数组上的位置，即标号。

```
const int maxnnode=1000; //Trie树的最多节点数
const int maxn=1000; //字符串的最长长度
struct Trie {
	int ch[maxnnode][26];
	int val[maxnnode];
	int size; //节点总数
}
```

## 后缀树

后缀树，就是把一串字符的所有后缀保存并且压缩的字典树。相对于字典树来说，后缀树**并不是针对大量字符串的，而是针对一个或几个字符串来解决问题**，比如**字符串的回文子串**，**两个字符串的最长公共子串**等等。
 
性质：一个字符串构造了一棵树，树中保存了该字符串所有的后缀。

### 应用

判断字符串s1是否是字符串s2的子串：如果是s1是s2的子串，那么s1一定是s2中某个后缀串的前缀。

获得字符串s1在字符串s2中重复的次数：计算s1出现的次数其实是看你s1是几个s2后缀串的前缀。

n个字符串的最长公共部分（广义后缀树）：当后缀树存储的字符串数量大于等于2就叫做广义后缀树。在之前后缀树数据结构的基础上，增加了区分字符串的符号。例如，增加一个int类型数据n，表示存放了多少个字符串的后缀，只有n为字符串的个数，才说明它们有前缀。

最长回文串（广义后缀树）：将字符串s1和它的逆s2建立一颗广义后缀树。然后求共同前缀。

### 参考

[Trie树和后缀树](https://blog.csdn.net/jinzhao1993/article/details/52966761)

## 树状数组

树状数组或者二叉索引树也称作Binary Indexed Tree，又叫做Fenwick树；它的查询和修改的时间复杂度都是log(n)，空间复杂度则为O(n)，这是因为树状数组通过**将线性结构转化成树状结构，从而进行跳跃式扫描**。通常使用在高效的**计算数列的前缀和，区间和**。

查询区间和以前的做法要么就是查询很慢，修改很快，那怎么办呢，那就存储前缀和来提高查询速度，但这样一来修改了之后要更新这些前缀和，更新又很慢；数组数组就完美地综合了这两种做法，**存储后缀和，更新后缀和**，通过**lowbit来限定后缀和的长度**，利用二进制使得查询、更新的时间复杂度都在O(logn)。

树状数组和线段树很像，但**能用树状数组解决的问题，基本上都能用线段树解决**，而**线段树能解决的树状数组不一定能解决**。相比较而言，**树状数组效率要高很多**。

### 数据结构

原数组arr，新开的数组c。c[i]表示从第i个元素向前数lowbit(i)个元素，这一段的和，就是**靠右端点的区间和**。

[树状数组简单易懂的详解](https://blog.csdn.net/flushhip/article/details/79165701)

### 操作

查询：查询任意一个区间的和，因为区间具有可加减性，故转化为求前缀和。时间复杂度O(logn)。

修改：修改某一元素时间内复杂度为O(1)，但还要更新c数组。

## 二叉树中寻找值最大的节点并返回

https://blog.csdn.net/SnailCpp/article/details/80035927

层次遍历

## 寻找二叉树每层的最大值

https://blog.csdn.net/dream161110/article/details/79091654

层次遍历

关键是要辨别出每层。然后输出每层的最大值。
