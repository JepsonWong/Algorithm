## Trie

又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是**用于统计，排序和保存大量的字符串**（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的**公共前缀**来减少查询时间，最大限度地减少无谓的字符串比较，**查询效率比哈希树高**。

Trie的强大之处就在于它的时间复杂度。它的**插入和查询时间复杂度都为O(k)**，其中k为key的长度，与Trie中保存了多少个元素无关。Hash表号称是O(1)的，但在计算hash的时候就肯定会是O(k) ，而且还有碰撞之类的问题；Trie的**缺点是空间消耗很高**。

至于**Trie树的实现，可以用数组，也可以用指针动态分配**，做题时为了方便可以用数组，静态分配空间。

源代码：

https://blog.csdn.net/nk\_test/article/details/47836119

https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html

https://blog.csdn.net/gao1440156051/article/details/51357135

指针模板/数组模板：https://blog.csdn.net/jinzhao1993/article/details/52966761

### 数据结构

指针模板：

```
#define MAX_CHILD 26
struct Node {
	int val; //前缀出现次数
	Node* next[MAX_CHILD];
	Node() {
		val = 0;
		memset(next, 0, sizeof(next));
	}
}
Node* root = new Node(); //创建一个新的Trie树
```

数组模板：父节点对儿子节点的指向是这样实现的，对每个节点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是儿子对应在大数组上的位置，即标号。

```
const int maxnnode=1000; //Trie树的最多节点数
const int maxn=1000; //字符串的最长长度
struct Trie {
	int ch[maxnnode][26];
	int val[maxnnode];
	int size; //节点总数
}
```

## 后缀树

后缀树，就是把一串字符的所有后缀保存并且压缩的字典树。相对于字典树来说，后缀树**并不是针对大量字符串的，而是针对一个或几个字符串来解决问题**，比如**字符串的回文子串**，**两个字符串的最长公共子串**等等。
 
性质：一个字符串构造了一棵树，树中保存了该字符串所有的后缀。

### 应用

判断字符串s1是否是字符串s2的子串：如果是s1是s2的子串，那么s1一定是s2中某个后缀串的前缀。

获得字符串s1在字符串s2中重复的次数：计算s1出现的次数其实是看你s1是几个s2后缀串的前缀。

n个字符串的最长公共部分（广义后缀树）：当后缀树存储的字符串数量大于等于2就叫做广义后缀树。在之前后缀树数据结构的基础上，增加了区分字符串的符号。例如，增加一个int类型数据n，表示存放了多少个字符串的后缀，只有n为字符串的个数，才说明它们有前缀。

最长回文串（广义后缀树）：将字符串s1和它的逆s2建立一颗广义后缀树。然后求共同前缀。

### 参考

[Trie树和后缀树](https://blog.csdn.net/jinzhao1993/article/details/52966761)

## 树状数组

树状数组或者二叉索引树也称作Binary Indexed Tree，又叫做Fenwick树；它的查询和修改的时间复杂度都是log(n)，空间复杂度则为O(n)，这是因为树状数组通过**将线性结构转化成树状结构，从而进行跳跃式扫描**。通常使用在高效的**计算数列的前缀和，区间和**。

查询区间和以前的做法要么就是查询很慢，修改很快，那怎么办呢，那就存储前缀和来提高查询速度，但这样一来修改了之后要更新这些前缀和，更新又很慢；数组数组就完美地综合了这两种做法，**存储后缀和，更新后缀和**，通过**lowbit来限定后缀和的长度**，利用二进制使得查询、更新的时间复杂度都在O(logn)。

树状数组和线段树很像，但**能用树状数组解决的问题，基本上都能用线段树解决**，而**线段树能解决的树状数组不一定能解决**。相比较而言，**树状数组效率要高很多**。

### 数据结构

原数组arr，新开的数组c。c[i]表示从第i个元素向前数lowbit(i)个元素，这一段的和，就是**靠右端点的区间和**。

[树状数组简单易懂的详解](https://blog.csdn.net/flushhip/article/details/79165701)

### 操作

查询：查询任意一个区间的和，因为区间具有可加减性，故转化为求前缀和。时间复杂度O(logn)。

修改：修改某一元素时间内复杂度为O(1)，但还要更新c数组。

## 二叉树中寻找值最大的节点并返回

https://blog.csdn.net/SnailCpp/article/details/80035927

层次遍历

## 寻找二叉树每层的最大值

https://blog.csdn.net/dream161110/article/details/79091654

层次遍历

关键是要辨别出每层。然后输出每层的最大值。
